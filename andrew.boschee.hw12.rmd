---
title: "Homework 12"
author: "Andrew Boschee"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F,warning=F,message=F)
```
```{r, echo = FALSE}
#install.packages('stats')
#install.packages('dendextend')
#install.packages('factoextra')
#install.packages('ggdendro')
library(ISLR)
library(stats)
library(ggplot2)
library(readr)
library(knitr)
library(dendextend)
library(cluster)
library(factoextra)
library(dplyr)
library(gridExtra)
library(ggdendro)

```

*No Collaborators. OUtside Resources: rpkgs.datanovia.com, rdocumentation.com, R Graphics Cookbook*

1. Question 10.7.8 pg 416: On the USArrests data, calculate PVE in two ways:
a. Using the sdev output of the prcomp() function, as was done in section 10.2.3
b. By applying Equation 10.8 directly. That is, use the prcomp() function to compute the principal component loadings. Then, use those loadings in Equation 10.8 to obtain the PVE.

```{r, echo = FALSE}
# set seed
set.seed(702)

# load dataset
data("USArrests")

# set states to rownames
states = row.names(USArrests)

# look at mean and variance by column
meanVals <- apply(USArrests, 2, mean)
varianceVals <- apply(USArrests, 2, var)

# find princiapl components
prOut <- prcomp(USArrests, scale = TRUE)
#names(prOut)

#prOut$center
#prOut$scale
#prOut$rotation
#biplot(prOut, scale = 0)
kable(meanVals, caption = 'Mean Values of Variables', col.names = NULL)

```

```{r, echo = FALSE, fig.width=10, fig.height=5}
#set seed
set.seed(702)
# rotate components
prOut$rotation = -prOut$rotation
prOut$x = -prOut$x

# plot components
biplot(prOut, scale = 0)
```


```{r, echo = FALSE}
set.seed(702)
# check standard deviation
#prOut$sdev
# calc variance
prstd <- prOut$sdev
prVar <- prOut$sdev^2
kable(prstd, col.names = 'Standard Deviation', caption = 'Standard Deviation of Each Variable', row.names= c(1,2,3,4))
# calc proportion of variance explained
pve <- prVar/sum(prVar)
pvedf <- as.data.frame(pve)
```

\pagebreak

```{r, echo = FALSE}
kable(pve, col.names = 'Proportion of Variance', row.names= c(1,2,3,4), caption = 'Proportion of Variance by Component')
```



```{r, echo = FALSE, fig.width=10, fig.height=5}
# base r plots
par(mfrow = c(1,2))
plot(pve, xlab = 'Principal Component', ylab = 'Proportion of Variance Explained', ylim = c(0,1), type = 'b')
plot(cumsum(pve), xlab = 'Principal Component', ylab = 'Cumulative Proportion of Variance Explained', ylim = c(0, 1), type = 'b')
```

For part A the sdev function was used to find the standard deviation for each principal component. The proportion of variance was then calculated for each component with values given in table 3

2. Question 10.7.9 pg 416: Consider the USArrests data. We will now perform hierarchical clustering on the states.

a. Using hierarchical clustering with complete linkage and Euclidean distance, cluster the states.

Data was loaded and the dist function was applied with euclidean method. Output was stored in distMat variable and hclust function applied model with complete method and stored in variable for plotting. Used plot() function and fviz_dend() function to see all states

```{r, echo = FALSE}
#set seed and load dataset
set.seed(702)
data <- USArrests

#summary(data)
#data1 <- scale(data)
# calc euclid distance
distMat <- dist(data, method = 'euclidean')
```
```{r, echo = FALSE}
# hclust with complete method
completeLink <- hclust(distMat, method = 'complete')
```


```{r, echo =FALSE, fig.width=10, fig.height=5}

```
```{r, echo = FALSE, fig.width = 10, fig.height=5}
# plot before scaling
plot(completeLink, main="Complete Linkage Before Scaling", xlab="", sub="", cex=.9)

fviz_dend(completeLink, cex = 0.5, color_labels_by_k = FALSE)
```


b. Cut the dendrogram  at a height that results in three distinct clusters. Which states belong to which clusters?

Using the cutree() function with second argument set to 3, for three clusters. Plots are now adjusted with color_branches() function to color code clusters. Prior to the graph, output from cutree shows every state with the corresponding cluster that it falls under.

```{r, echo = FALSE, fig.width=10, fig.height=5}
# cut tree at k = 3
completeLinkCut <- cutree(completeLink, 3)
completeLinkCut
```

```{r, echo = FALSE, fig.width =10, fig.height=5}
# as.dendrogram and color by branch
nonScaleDend <- as.dendrogram(completeLink)
nonScaleColoredDend <- color_branches(nonScaleDend, k=3)
plot(nonScaleColoredDend, main = 'Complete Linkage Before Scaling - K = 3')

```

c. Hierarchically cluster the states using complete linkage and Euclidean distance, after scaling the variables to have standard deviation one.

Steps from prior question repeated after modifying the dataset applying the scale() function. Can see with the scaling, that there are now many more states in the first cluster

```{r, echo = FALSE, fig.width=10, fig.height=5}
# calce data and calculate distance again
data1 <- scale(data)
distMat1 <- dist(data1, method = 'euclidean')
# build new model with scaled data
completeLink2 <- hclust(distMat1, method = 'complete')
```

```{r, echo = FALSE, fig.width=10, fig.height=5}
#plot(completeLink2, main="Complete Linkage After Scaling", xlab="", sub="", cex=.9)
completeLinkCut2 <- cutree(completeLink2, k=3)
var <- as.dendrogram(completeLink2)
coloredDend <- color_branches(var, k=3)
plot(coloredDend, main = 'Complete Linkage After Scaling - K = 3')
# use fviz_dend and color by k
fviz_dend(completeLink2, cex = 0.5, k = 3, color_labels_by_k = TRUE)
```



d. What effect does scaling the variables have on the hierarchical clustering obtained? In your opinion, should the variables be scaled before the inter-observation dissimilarities are computed? Provide a justification for your answer.

From the plot below, we can see that there are much more defined clusters after scaling is put into place. If using this plot as visual aid, the scaled version would be very helpful, while the non-scaled would cause much confusion and is hard to read. 

```{r, echo = FALSE, fig.height = 5, fig.width = 10}
# eclust function to show difference between scaled and non-scaled
complete3 <- eclust(data1, 'hclust', hc_metric = 'euclidean', hc_method = 'complete', k=3)
complete4 <- eclust(data, 'hclust', hc_metric = 'euclidean', hc_method = 'complete', k=3)

#output with grid arrange
grid.arrange(
fviz_cluster(complete3),
fviz_cluster(complete4),
nrow=1)
```

3. Question 10.7.11 pg 417: On the book website, www.StatLearning.com, there is a gene expression data set (ch10Ex11.csv) that consists of 40 tissue samples with measurements on 1000 genes. the first 20 samples are from healthy patients, while the second 20 are from a diseased group.

a. Load in the data using read.csv(). You will need to select header = F.

Used read.csv function as specifed and stored as geneData variable with first five columns and rows shown.

```{r, echo = FALSE}
# load dataset
geneData <- read.csv('ch10Ex11.csv', header = F)
geneData[1:5,1:5]
```

b. Apply hierarchical clustering to the samples using correlation based distance, and plot the dendrogram. Do the genes separate the samples into the two groups? Do your results depend on the type of linkage used?

The complete and single methods both do a good job separating into two groups. The average method ends up giving an output with three groups.


```{r, echo = FALSE}
set.seed(702)
# build three different model types
dd <- as.dist(1-cor(geneData))
completeLinkGene <- hclust(dd, method = 'complete')
avgLinkGene <- hclust(dd, method = 'average')
singleLinkGene <- hclust(dd, method = 'single')

```


```{r, echo =FALSE, fig.width=10, fig.height=5}
# plot three different models
par(mfrow = c(2,2))
plot(completeLinkGene)
plot(avgLinkGene)
plot(singleLinkGene)
```

```{r, echo = FALSE, fig.height=5, fig.width=10}
# repeat with fviz_dend function
grid.arrange(
fviz_dend(completeLinkGene, cex = 0.5, color_labels_by_k = FALSE),
fviz_dend(avgLinkGene, cex = 0.5, color_labels_by_k = FALSE),
fviz_dend(singleLinkGene, cex = 0.5, color_labels_by_k = FALSE),
nrow=2)

```

\pagebreak

c. Your collaborator wants to know which genes differ the most across the two groups. Suggest a way to answer this question, and apply it here.

Performed PCA to find where the most variance occurs and order descending. To show results the top ten are stored in vector and output below.

```{r, echo = FALSE}
# pca on geneData
geneDiff <- prcomp(t(geneData))
# order results
diffList <- order(abs(rowSums(geneDiff$rotation)), decreasing = T)

# pick top ten
topDiff <- diffList[1:10]

kable(topDiff, caption = 'Top 10 Differing Genes', col.names = NULL)
```


